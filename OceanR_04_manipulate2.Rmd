---
title: "Manipulating Data Part 2"
output: 
  html_document:
    toc: true
    toc_float: true
---

## Load your Rda file
Use the function ***load()*** to bring your dataframe into the R environment. 
```{r}
load("BATSdata.Rda")
```

## For Loops
For loops are a fun alternative to lists for passing separate chunks of data through a function. For loops are used to iterate over a vector (run the same thing multiple times)

```{r eval=F}
for (val in sequence)
{
    statement
}
```

The 'val' represents a value within the vector 'sequence'. Each 'val' gets passed through the 'statement', which is what we want R to do for us.

Now let's use a For loop to calculate the maximum temp for each cruise. We need to do a couple things before we let R calculate the max temps. First, we need to specify what our vector, which will be cruise number. Second, we need to create a place for the For loop to put our resulting data. If we don't do that, if will just show the last value that it calculated.
```{r}
# create vector of cruise numbers that we want to look at
cruises <- c(seq(1:max(data$cruise)))
# create vector to put the resulting data
result <- rep(NA,length(cruises))

for(i in cruises){
  result[i] <- max(data[data$cruise==i,"Temp"], na.rm=T)
}
head(result)
result[300]
```
Different goals may call for different approaches in terms of using an lapply function with lists or passing data through For loops. 

***Note***: If you pass a list through a function and get an error, nothing will be returned. However, if you get an error while using a For loop, the loop will stop at the place where the error occurred. This can be very helpful when you are debugging your code.
  
## Writing your own function
The are many functions already available for you in R, but sometimes you need to be able to write your own. To do this, we use **function()**.
```{r eval=F}
function(x){
  statements
  return(something)
}
```

For example, let's make a function that converts celsius into farhenheit. After you run the lines containing the function, it will show up in your Environment window under "Functions".
```{r}
c2f <- function(x){
  degF <- (x * (9/5)) +32
  result <- paste(x," degrees C is equal to ",degF," degrees F", sep="")
  return(result)
}

# now use the function to check temp of 12C
c2f(12)
```
Notice that 'degF' is not shown in your Environment window. This is because things that happen in functions stay in functions, unless you tell it to return that value.     

***Note***: you can skip writing **return()** and just write the variable name if you want to save keystrokes.  

Writing your own functions can even allow you to use R to go fishing!
```{r}
# prompt "Do you want to fish"
fishing <- function(){
  x <- readline("Do you want to fish, y or n?")  
  out1 <- sample(0:3,1)
  out2 <- sample(0:3,1)
  out3 <- ifelse(out1 == out2, "You caught a fish!", "No fish for you :-(")
  ifelse(x %in% c("y","Y"), out3, "Maybe next time")
}  

fishing()
```
  
Now let's try something a little more complicated (and science-y). The BATS dataset is comprised of multiple casts that fire bottles at the same depths but may be used for different analyses. Let's write a function that will index the dataframe and return observations (rows) that contain measurements of either TOC or TN. For simplicity, we will limit ourselves to working with a single cruise (250).
```{r}
# subset dataframe to only look at cruise 250
cruise.250 <- data[data$cruise==250,]
```

First, we need to split up each cruise into separate casts.
```{r}
# split df into separate casts
cast.list<- split(cruise.250, cruise.250$cast)
# identify casts containing TOC or TN collected from the same bottle
findDOM.func <- function(x){
    DOM <- x[!(is.na(x$TOC) | is.na(x$TN)),]
    return(DOM)
}
# run the list through the function
DOM.list <- lapply(cast.list, findDOM.func)

# alternatively, we can wirte the function within the lapply command
DOM.list2 <- lapply(cast.list, function(x){
  DOM <- x[!(is.na(x$TOC) | is.na(x$TN)),]
  return(DOM)
})
```

Now, check the structure of DOM.list
```{r eval=F}
str(DOM.list)
```

You see that while DOM.list still has eight elements (one for each cast), some of them are empty while others contain data. All of the elements containing data have values for either TOC or TN. As we showed in this example, functions can be use heirarchically, so that a function can use other functions within it. 

### Changing a list to a dataframe
Sometimes we want to return a list back into a single dataframe. An easy way to do this is using the function **rbindlist()** which is in the 'data.table' package (you installed this earlier). sing **rbindlist()** alone creates an object that is both a data.table and a data.frame, which can confuse downstream processes). To solve this, we will also use the function **data.frame()**, which will force our new object to just be a data.frame.
```{r}
library(data.table) # makes the package available

#bind list elements into a dataframe called DOM.df
DOM.df <- data.frame(rbindlist(DOM.list))
str(DOM.df) # check structure
```

